/*****************************************************************************
 *            Created: 20/03/2012
 *          Copyright: (C) Copyright David Goodwin, 2012
 *            License: GNU General Public License
 *****************************************************************************
 *
 *   This is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This software is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this software; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 ****************************************************************************/

/*
 * Note: This function contains Embedded SQL. It must be pre-processed with
 * ECPG before you can run it through your C compiler.
 */

/* Functions in this file start with the pgo_ prefix as some names (connect)
 * were conflicting with functions elsewhere and getting called by library
 * code somehow.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "pgout.h"
#include "common.h"
#include "version.h"

FILE* database_log_file = NULL;

static char* wind_direction[] = {"N", "NNE", "NE", "ENE", "E", "ESE", "SE",
                                "SSE", "S", "SSW", "SW", "WSW", "W", "WNW",
                                "NW", "NNW", "INV"};
#define WIND_DIR(byte) (wind_direction[byte > 15 ? 16 : byte])

EXEC SQL WHENEVER SQLERROR CALL pgo_print_sqlca();

/* In the event of a SQL error, print the details to stderr, roll back the
 * transaction, disconnect from the server and exit */
void pgo_print_sqlca()
{
    if (database_log_file == NULL) database_log_file = stderr;

    fprintf(database_log_file, "==== sqlca ====\n");
    fprintf(database_log_file, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(database_log_file, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(database_log_file, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(database_log_file, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(database_log_file, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(database_log_file, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(database_log_file, "===============\n");
    exit(EXIT_FAILURE);
   /* rollback();
    disconnect();
    exit(EXIT_FAILURE);*/
}

/* Connect to the database server */
void pgo_connect(const char *target, const char *username, const char *password) {
    EXEC SQL BEGIN DECLARE SECTION;
    const char * target_l = target;
    const char * username_l = username;
    const char * password_l = password;
    EXEC SQL END DECLARE SECTION;

    fprintf(database_log_file,"Connecting to database %s\n", target);

    EXEC SQL CONNECT TO :target_l USER :username_l USING :password_l;

    EXEC SQL SET AUTOCOMMIT TO OFF;

}

/* Checks that that the specified station type is a fine offset WH1080 */
int pgo_check_station_type(char* station_code) {
    EXEC SQL BEGIN DECLARE SECTION;
    int ret_val;
    const char* station_code_param = station_code;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL select case when st.code = 'FOWH1080' then 1
                         else 0
                    end as hc
                    into :ret_val
             from station s
             inner join station_type st on st.station_type_id = s.station_type_id
             where s.code = :station_code_param;

    return ret_val;
}

/* Gets the database schema version */
int pgo_get_db_version() {
    EXEC SQL BEGIN DECLARE SECTION;
    int db_version;
    int is_v1_schema;
    EXEC SQL END DECLARE SECTION;

    /* Only the v1 schema lacks the db_info table */
    EXEC SQL select v1_check.v1_schema
                    into :is_v1_schema
             from (
                select 0 as v1_schema
                where exists (select *
                              from information_schema.tables
                              where table_schema = 'public' and table_name = 'db_info')
                union
                select 1 as v1_schema
                where not exists (select *
                                  from information_schema.tables
                                  where table_schema = 'public' and table_name = 'db_info')
             ) v1_check;

    if (is_v1_schema)
        return 1;

    /* If we got this far then db_info exists and we can check it to see what
     * the DB version is. */
    EXEC SQL select v::integer
             into :db_version
             from DB_INFO
             where k = 'DB_VERSION';

    return db_version;
}

/* Checks that the application isn't tool old for the database. */
int pgo_check_min_version() {
    EXEC SQL BEGIN DECLARE SECTION;
    int compatible;
    int major = VERSION_MAJOR;
    int minor = VERSION_MINOR;
    int revision = VERSION_REV;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL select case when version_check = true then 1
            when version_check = false then 0
            end as vc
            into :compatible
            from version_check('',0,2,0);


    return compatible;
}

/* Looks up the ID for the specified station code */
long pgo_get_station_id(const char* station_code) {
    EXEC SQL BEGIN DECLARE SECTION;
    long ret_val;
    const char* station_code_param = station_code;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT station_id
             INTO :ret_val
             FROM station
             WHERE code = :station_code_param;

    return ret_val;
}

/* Get the record number and time stamp for the most recent sample in the
 * database */
void pgo_get_last_record_number(unsigned short *record_number,
                                time_t *time_stamp,
                                long station_id) {
    EXEC SQL BEGIN DECLARE SECTION;
    long int ts = 0;
    int rn = 0;
    long station_id_param = station_id;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT extract(epoch from time_stamp)::bigint,
                    record_number
             INTO :ts, :rn
             FROM public.wh1080_latest_record_number
             WHERE station_id = :station_id_param;

    *record_number = rn;
    *time_stamp = (time_t)ts;
}

/* Insert a history set into the database. All records in the history set will
 * be inserted in order */
void pgo_insert_history_set(history_set hs, long station_id) {
    unsigned int i = 0;
    history h;

    EXEC SQL BEGIN DECLARE SECTION;
    unsigned short sample_time;
    unsigned short indoor_relative_humidity;
    float indoor_temperature;
    unsigned short relative_humidity;
    float temperature;
    float absolute_pressure;
    float average_wind_speed;
    float gust_wind_speed;
    char* wind_direction_str;
    float total_rain;
    int rain_overflow;
    int invalid_data;
    unsigned short record_number;
    long download_time;
    long time_stamp;
    int last_in_set;
    long station_id_param = station_id;
    long new_sample_id;
    EXEC SQL END DECLARE SECTION;

    for (i = 0; i < hs.record_count; i += 1) {
        h = hs.records[i];
        sample_time = h.sample_time;
        indoor_relative_humidity = h.indoor_relative_humidity;
        indoor_temperature = SFP(h.indoor_temperature);
        relative_humidity = h.outdoor_relative_humidity;
        temperature = SFP(h.outdoor_temperature);
        absolute_pressure = SFP(h.absolute_pressure);
        average_wind_speed = SFP(h.average_wind_speed);
        gust_wind_speed = SFP(h.gust_wind_speed);
        wind_direction_str = WIND_DIR(h.wind_direction);
        total_rain = h.total_rain * RAIN_MULTIPLY;
        rain_overflow = CHECK_BIT_FLAG(h.status, H_SF_RAINFALL_OVERFLOW);
        invalid_data = CHECK_BIT_FLAG(h.status, H_SF_INVALID_DATA);
        record_number = h.record_number;
        download_time = h.download_time;
        time_stamp = h.time_stamp;
        last_in_set = h.last_in_set;

        if (invalid_data) {
            /* Only insert the readings taken by the console as the readings
               from the outdoor sensor unit are missing and any data we pulled
               off the console that is normally collected by the outdoor sensors
               will be garbage. */
            EXEC SQL INSERT INTO sample(download_timestamp,
                                        time_stamp,
                                        indoor_relative_humidity,
                                        indoor_temperature,
                                        absolute_pressure,
                                        station_id
                                        )
                    VALUES(/* :download_time and :time_stamp are in UNIX time
                            * (seconds since the epoch, 1970-01-01 00:00:00 GMT).
                            * So we must convert them. */
                           (('epoch'::timestamp) + :download_time * '1 second'::interval) AT TIME ZONE 'GMT',
                           (('epoch'::timestamp) + :time_stamp * '1 second'::interval) AT TIME ZONE 'GMT',
                           :indoor_relative_humidity,
                           :indoor_temperature,
                           :absolute_pressure,
                           :station_id_param)
                    RETURNING sample_id INTO :new_sample_id;
        } else {
            EXEC SQL INSERT INTO sample(download_timestamp,
                                        time_stamp,
                                        indoor_relative_humidity,
                                        indoor_temperature,
                                        relative_humidity,
                                        temperature,
                                        absolute_pressure,
                                        average_wind_speed,
                                        gust_wind_speed,
                                        station_id
                                        )
                    VALUES(/* :download_time and :time_stamp are in UNIX time
                            * (seconds since the epoch, 1970-01-01 00:00:00 GMT).
                            * So we must convert them. */
                           (('epoch'::timestamp) + :download_time * '1 second'::interval) AT TIME ZONE 'GMT',
                           (('epoch'::timestamp) + :time_stamp * '1 second'::interval) AT TIME ZONE 'GMT',
                           :indoor_relative_humidity,
                           :indoor_temperature,
                           :relative_humidity,
                           :temperature,
                           :absolute_pressure,
                           :average_wind_speed,
                           :gust_wind_speed,
                           :station_id_param)
                    RETURNING sample_id INTO :new_sample_id;
        }

        EXEC SQL INSERT INTO wh1080_sample(sample_interval,
                                           record_number,
                                           last_in_batch,
                                           invalid_data,
                                           total_rain,
                                           rain_overflow,
                                           wind_direction,
                                           sample_id)
                VALUES(:sample_time,
                       :record_number,
                       :last_in_set,
                       :invalid_data,
                       :total_rain,
                       :rain_overflow,
                       :wind_direction_str,
                       :new_sample_id);
    }
}

void pgo_update_live(history live_record, long station_id) {

    EXEC SQL BEGIN DECLARE SECTION;
    unsigned short indoor_relative_humidity;
    float indoor_temperature;
    unsigned short relative_humidity;
    float temperature;
    float absolute_pressure;
    float average_wind_speed;
    float gust_wind_speed;
    char* wind_direction_str;
    long download_time;
    long station_id_param = station_id;
    EXEC SQL END DECLARE SECTION;
    int invalid_data;

    indoor_relative_humidity = live_record.indoor_relative_humidity;
    indoor_temperature = SFP(live_record.indoor_temperature);
    relative_humidity = live_record.outdoor_relative_humidity;
    temperature = SFP(live_record.outdoor_temperature);
    absolute_pressure = SFP(live_record.absolute_pressure);
    average_wind_speed = SFP(live_record.average_wind_speed);
    gust_wind_speed = SFP(live_record.gust_wind_speed);
    wind_direction_str = WIND_DIR(live_record.wind_direction);
    invalid_data = CHECK_BIT_FLAG(live_record.status, H_SF_INVALID_DATA);
    download_time = live_record.download_time;

    if (invalid_data) {
        /* When the record is marked as invalid it means all fields collected
           by the outdoor sensor unit will contain garbage except the wind
           direction (which will be "INV") */
        EXEC SQL UPDATE live_data
             SET download_timestamp = (('epoch'::timestamp) + :download_time * '1 second'::interval) AT TIME ZONE 'GMT',
                 indoor_relative_humidity = :indoor_relative_humidity,
                 indoor_temperature = :indoor_temperature,
                 absolute_pressure = :absolute_pressure
             WHERE station_id = :station_id_param;
    } else {
        EXEC SQL UPDATE live_data
             SET download_timestamp = (('epoch'::timestamp) + :download_time * '1 second'::interval) AT TIME ZONE 'GMT',
                 indoor_relative_humidity = :indoor_relative_humidity,
                 indoor_temperature = :indoor_temperature,
                 relative_humidity = :relative_humidity,
                 temperature = :temperature,
                 absolute_pressure = :absolute_pressure,
                 average_wind_speed = :average_wind_speed,
                 gust_wind_speed = :gust_wind_speed,
                 wind_direction = wind_direction_to_degrees(:wind_direction_str)
             WHERE station_id = :station_id_param;
    }
    EXEC SQL COMMIT;
}

/* Called to notify other database users that we've finished updating data
 * for now
 * WARNING: This commits the current transaction
 */
void pgo_updates_complete(char *station_code) {
    EXEC SQL BEGIN DECLARE SECTION;
    char* station_code_param = station_code;
    int foo;
    EXEC SQL END DECLARE SECTION;

    /* Stupid hack. If we don't select INTO something ECPG complains about
       too few arguments. */
    EXEC SQL SELECT 42 INTO :foo
             FROM pg_notify('update_complete',:station_code_param);

    EXEC SQL COMMIT;
}

/* Commits the transaction that was opened when we connected */
void pgo_commit() {
    EXEC SQL COMMIT;
}

/* roll-back any current transaction */
void pgo_rollback() {
    EXEC SQL ROLLBACK;
}

/* Disconnect from the database server */
void pgo_disconnect() {
    EXEC SQL DISCONNECT ALL;
}
