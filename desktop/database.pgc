/*****************************************************************************
 *            Created: 23/06/2012
 *          Copyright: (C) Copyright David Goodwin, 2012
 *            License: GNU General Public License
 *****************************************************************************
 *
 *   This is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This software is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this software; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 ****************************************************************************/

/*
 * QtSQL module doesn't seem to like Postgres (at least not recent versions).
 * So this is all done with ECPG instead. Yay.
 *
 * Remember: Keep it ANSI_C. Mostly. ECPG doesn't understand C++ but a little
 * bit of it (like the DBSignalAdapter stuff) shouldn't bother it too much.
 */

#include "database.h"
#include <string.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <QtDebug>
#include <math.h>
#include "dbsignaladapter.h"

#define LIVE_DATA_UPDATE_CHANNEL "live_data_updated"
#define NEW_IMAGE_CHANNEL "new_image"
#define NEW_SAMPLE_CHANNEL "new_sample_id"

/* Globals */
static DBSignalAdapter* signalAdapter = NULL;
static int station_id = 0;
static char* station_code = 0;
static int station_code_len = 0;
static int station_hw_type = 0;
static int db_version = 1;
static bool connected = false;

/* Forward Declarations */
int wdb_get_station_id(const char*);

/* Setup error handling */
EXEC SQL WHENEVER SQLERROR CALL wdb_print_sqlca();

/* In the event of a SQL error, print the details to stderr, roll back the
 * transaction, disconnect from the server and exit */
void wdb_print_sqlca()
{
    fprintf(stderr, "A database error has occurred.\n");
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");

    if (signalAdapter != NULL)
        signalAdapter->raiseDatabaseError(sqlca.sqlcode,
                                          sqlca.sqlerrm.sqlerrml,
                                          sqlca.sqlerrm.sqlerrmc,
                                          sqlca.sqlerrd,
                                          sqlca.sqlwarn,
                                          sqlca.sqlstate);
    else
        exit(EXIT_FAILURE);
}

void wdb_set_signal_adapter(DBSignalAdapter *adapter) {
    signalAdapter = adapter;
}

/* Checks that the main connection is still OK and if it isn't attempts to
 * reset it */
void check_data_connection() {
    PGconn* conn = ECPGget_PGconn("data_connection");
    if (conn == NULL) {
        qDebug() << "ERROR: NULL connection (primary)";
    }

    /* PQstatus doesn't seem to notice a lost database connection until we do
     * something else that interacts with the connection (like run a query).
     *
     * This may be a result of interference from ECPG as a similar check
     * on the notification connection (which doesn't use ECPG for anything
     * beyond setting up the connection) doesn't have this problem.
     *
     * Similar interference may be the reason why notifications have to be
     * processed on a separate connection too (if we listen on data_connection
     * we never receive them).
     */
    PQconsumeInput(conn);

    if (PQstatus(conn) == CONNECTION_BAD) {
        qDebug() << "Primary database connection seems to have gone bad. Attempting reset.";
        PQreset(conn);
        if (PQstatus(conn) == CONNECTION_BAD) {
            qDebug() << "ERROR: Failed to reestablish primary database connection.";
        } else {
            qDebug() << "Primary reconnect succeeded.";
        }
    }
}

/* Tries to figure out which version the database is. */
int get_db_version() {
    EXEC SQL BEGIN DECLARE SECTION;
    bool db_info_table_exists;
    int version;
    EXEC SQL END DECLARE SECTION;

    check_data_connection();

    EXEC SQL SELECT COUNT(*) = 1 INTO :db_info_table_exists
             FROM information_schema.tables WHERE table_name = 'db_info';

    /* v0.1 doesn't have the db_info table. Everything else should. */
    if (!db_info_table_exists)
        version = 1;
    else {
        /* For v0.2+ we can just ask the database what version it is */
        EXEC SQL SELECT CAST(v AS integer) INTO :version
                 FROM db_info WHERE k = 'DB_VERSION';
    }

    return version;
}

void subscribe_to_notifications(PGconn* conn) {
    PGresult *res = PQexec(conn, "LISTEN " LIVE_DATA_UPDATE_CHANNEL);
    if (PQresultStatus(res) != PGRES_COMMAND_OK) {
        qDebug() << "LISTEN failed. Live data notifications will not be processed.\n";
    }
    PQclear(res);

    // This only works on v1.x
    res = PQexec(conn, "LISTEN " NEW_IMAGE_CHANNEL);
    if (PQresultStatus(res) != PGRES_COMMAND_OK) {
        qDebug() << "LISTEN failed. New image notifications will not be processed.\n";
    }
    PQclear(res);

    // This probably only works on v1.x
    res = PQexec(conn, "LISTEN " NEW_SAMPLE_CHANNEL);
    if (PQresultStatus(res) != PGRES_COMMAND_OK) {
        qDebug() << "LISTEN failed. New sample notifications will not be processed.\n";
    }
    PQclear(res);
}

bool wdb_connect(const char *target, const char *username, const char* password,
                 const char *station) {
    EXEC SQL BEGIN DECLARE SECTION;
    const char * target_l = target;
    const char * username_l = username;
    const char * password_l = password;
    int hw_type;
    int stat_id;
    EXEC SQL END DECLARE SECTION;


    qDebug() << "Connecting to database...";

    // This is the primary connection and is used for all queries.
    EXEC SQL CONNECT TO :target_l AS data_connection USER :username_l USING :password_l;

    if (sqlca.sqlstate[0] != '0' || sqlca.sqlstate[1] != '0')
        return false;

    db_version = get_db_version();
    qDebug() << "Database version: " << db_version;

    qDebug() << "Setting up notification connection...";
    // This connection is used to listen for notifications. This is done on a
    // seperate connection because performing selects with ECPG seems to
    // interfere with receiving notifications.
    EXEC SQL CONNECT TO :target_l AS notification_connection USER :username_l USING :password_l;

    /* Subscribe to live data notifications */
    PGconn* conn = ECPGget_PGconn("notification_connection");
    if (conn == NULL) return false;
    subscribe_to_notifications(conn);

    // Switch back to the primary connection and finish off.
    EXEC SQL SET CONNECTION data_connection;
    EXEC SQL SET AUTOCOMMIT TO OFF;

    if (db_version > 1)
        station_id = wdb_get_station_id(station);

    station_code_len = strlen(station) + 1; /* +1 for null termination */
    station_code = (char*)malloc(station_code_len);
    memcpy(station_code, station, station_code_len);

    /* Figure out what sort of hardware this station has */
    stat_id = station_id;
    EXEC SQL SELECT CASE WHEN upper(st.code) = 'GENERIC' THEN 0
                         WHEN upper(st.code) = 'FOWH1080' THEN 1
                         WHEN upper(st.code) = 'DAVIS' THEN 2
                         ELSE 0
                    END
             INTO :hw_type
             FROM station s
             INNER JOIN station_type st
                     ON s.station_type_id = st.station_type_id
             WHERE s.station_id = :stat_id;
    station_hw_type = hw_type;

    connected = true;

    return connected;
}

/* Gets the ID for the specified station code */
int wdb_get_station_id(const char* station) {
    EXEC SQL BEGIN DECLARE SECTION;
    const char * station_code = station;
    int station_id_param = 0;
    EXEC SQL END DECLARE SECTION;

    qDebug() << "Getting station id...";

    if (db_version >= 2) {
        qDebug() << "V2+ DB: station " << station;
        EXEC SQL SELECT station_id
                 INTO :station_id_param
                 FROM station
                 WHERE upper(code) = upper(:station_code);
    } else {
        qDebug() << "V1 DB: skip";
        station_id_param = 0;
    }

    return station_id_param;
}

void wdb_disconnect() {
    EXEC SQL DISCONNECT data_connection;
    EXEC SQL DISCONNECT notification_connection;
    free(station_code);
}

notifications wdb_live_data_available() {
    //qDebug() << "Checking for live data";

    notifications n;
    n.live_data = false;
    n.new_image = false;
    n.image_id = -1;
    n.new_sample = false;
    n.sample_id = -1;

    if (!connected) return n;

    PGconn* conn = ECPGget_PGconn("notification_connection");
    if (conn == NULL) {
        qDebug() << "ERROR: NULL connection (secondary)";
        return n;
    }

    if (PQstatus(conn) == CONNECTION_BAD) {
        qDebug() << "Secondary database connection seems to have gone bad. Attempting reset.";
        PQreset(conn);
        if (PQstatus(conn) == CONNECTION_BAD) {
            qDebug() << "ERROR: Failed to reestablish secondary database connection.";
        } else {
            qDebug() << "Secondary reconnect succeeded.";
            subscribe_to_notifications(conn);
        }
    }
    PGnotify* notification;
    PQconsumeInput(conn);
    while ((notification = PQnotifies(conn)) != NULL) {
/*        qDebug() << "Received notification:" << notification->relname << notification->extra;*/

        if (strcmp(notification->relname, LIVE_DATA_UPDATE_CHANNEL) == 0) {
            if (db_version <= 1) {
                /* the v1 schema doesn't use the payload to indicate station */
                n.live_data = true;
            }
            /* For v2+ schema we need to check the payload to ensure this is
             * for the station we're interested in */
            else if (strncasecmp(station_code, notification->extra, station_code_len) == 0) {
                // Live data is available for the station we are subscribed to.
                n.live_data = true;
            } else {
                /* It's a notification on a v2+ database for a station other
                 * than the one we're interested in. */
                n.live_data = false;
            }
        } else if (strcmp(notification->relname, NEW_IMAGE_CHANNEL) == 0) {
            /* A new image is available! The payload is the Image ID*/
            n.new_image = true;
            n.image_id = atoi(notification->extra);
        } else if (strcmp(notification->relname, NEW_SAMPLE_CHANNEL) == 0) {
            /* A new sample is available! The payload is station_code:sample_id */
            char* part = strtok(notification->extra, ":");
            /* First bit should be station code */
            if (part != NULL && strncasecmp(station_code, part, station_code_len) == 0) {
                part = strtok(NULL, ":");
                if (part) {
                    n.sample_id = atoi(part);
                    n.new_sample = true;
                }
            }
        } else {
            qDebug() << "Ignore: Unknown channel";
        }
        PQfreemem(notification);
    }

    return n;
}

/* For zxweather v0.1 databases */
live_data_record get_live_data_v1() {
    EXEC SQL BEGIN DECLARE SECTION;
    int indoor_relative_humidity = 0;
    float indoor_temperature = 0.0;
    int relative_humidity = 0;
    float temperature = 0.0;
    float dew_point = 0.0;
    float wind_chill = 0.0;
    float apparent_temperature = 0.0;
    float absolute_pressure = 0.0;
    float average_wind_speed = 0.0;
    char wind_direction[4];
    long download_timestamp = 0;
    EXEC SQL END DECLARE SECTION;

    qDebug() << "V1 data load";

    memset(wind_direction, '\0', sizeof(char) * 4);

    check_data_connection();

    EXEC SQL SELECT ld.indoor_temperature,
                    ld.indoor_relative_humidity,
                    ld.temperature,
                    ld.relative_humidity,
                    ld.dew_point,
                    ld.wind_chill,
                    ld.apparent_temperature,
                    ld.absolute_pressure,
                    ld.average_wind_speed,
                    ld.wind_direction,
                    extract(epoch from ld.download_timestamp)::integer
             INTO :indoor_temperature,
                  :indoor_relative_humidity,
                  :temperature,
                  :relative_humidity,
                  :dew_point,
                  :wind_chill,
                  :apparent_temperature,
                  :absolute_pressure,
                  :average_wind_speed,
                  :wind_direction,
                  :download_timestamp
             FROM live_data ld
             LIMIT 1;

    live_data_record rec;
    rec.indoor_temperature = indoor_temperature;
    rec.indoor_relative_humidity = indoor_relative_humidity;
    rec.temperature = temperature;
    rec.relative_humidity = relative_humidity;
    rec.dew_point = dew_point;
    rec.wind_chill = wind_chill;
    rec.apparent_temperature = apparent_temperature;
    rec.absolute_pressure = absolute_pressure;
    rec.average_wind_speed = average_wind_speed;
    rec.download_timestamp = download_timestamp;
    rec.v1 = true;
    strcpy(rec.wind_direction_str, wind_direction);

    return rec;
}

/* For v0.2+ */
live_data_record get_live_data_v2() {
    EXEC SQL BEGIN DECLARE SECTION;
    int indoor_relative_humidity = 0;
    float indoor_temperature = 0.0;
    int relative_humidity = 0;
    float temperature = 0.0;
    float dew_point = 0.0;
    float wind_chill = 0.0;
    float apparent_temperature = 0.0;
    float absolute_pressure = 0.0;
    float average_wind_speed = 0.0;
    int wind_direction = 0;
    int wind_direction_null;
    long download_timestamp = 0;
    int station_id_param = station_id;    

    /* Extra stuff for Davis hardware: */
    float rain_rate = 0.0;
    float storm_rain = 0.0;
    long current_storm_date = 0;
    int barometer_trend = 0;
    int forecast_icon = 0;
    int forecast_rule = 0;
    int tx_battery_status = 0;
    float console_battery_voltage = 0.0;
    float uv_index = 0.0;
    float solar_radiation = 0.0;

    double leafWetness1 = NAN;
    double leafWetness2 = NAN;
    double leafTemperature1 = NAN;
    double leafTemperature2 = NAN;
    double soilMoisture1 = NAN;
    double soilMoisture2 = NAN;
    double soilMoisture3 = NAN;
    double soilMoisture4 = NAN;
    double soilTemperature1 = NAN;
    double soilTemperature2 = NAN;
    double soilTemperature3 = NAN;
    double soilTemperature4 = NAN;
    double extraTemperature1 = NAN;
    double extraTemperature2 = NAN;
    double extraTemperature3 = NAN;
    double extraHumidity1 = NAN;
    double extraHumidity2 = NAN;

    // These sensors can all have null values so we must have indicator variables for them.
    int leafWetness1_ind = 0;
    int leafWetness2_ind = 0;
    int leafTemperature1_ind = 0;
    int leafTemperature2_ind = 0;
    int soilMoisture1_ind = 0;
    int soilMoisture2_ind = 0;
    int soilMoisture3_ind = 0;
    int soilMoisture4_ind = 0;
    int soilTemperature1_ind = 0;
    int soilTemperature2_ind = 0;
    int soilTemperature3_ind = 0;
    int soilTemperature4_ind = 0;
    int extraTemperature1_ind = 0;
    int extraTemperature2_ind = 0;
    int extraTemperature3_ind = 0;
    int extraHumidity1_ind = 0;
    int extraHumidity2_ind = 0;

    EXEC SQL END DECLARE SECTION;

    qDebug() << "V2 data load for station id" << station_id_param;

    check_data_connection();

    EXEC SQL SELECT ld.indoor_temperature,
                    ld.indoor_relative_humidity,
                    ld.temperature,
                    ld.relative_humidity,
                    ld.dew_point,
                    ld.wind_chill,
                    ld.apparent_temperature,
                    ld.absolute_pressure,
                    ld.average_wind_speed,
                    ld.wind_direction,
                    extract(epoch from ld.download_timestamp)::integer
             INTO :indoor_temperature,
                  :indoor_relative_humidity,
                  :temperature,
                  :relative_humidity,
                  :dew_point,
                  :wind_chill,
                  :apparent_temperature,
                  :absolute_pressure,
                  :average_wind_speed,
                  :wind_direction :wind_direction_null,
                  :download_timestamp
             FROM live_data ld
             WHERE ld.station_id = :station_id_param
             LIMIT 1;

    live_data_record rec;
    rec.indoor_temperature = indoor_temperature;
    rec.indoor_relative_humidity = indoor_relative_humidity;
    rec.temperature = temperature;
    rec.relative_humidity = relative_humidity;
    rec.dew_point = dew_point;
    rec.wind_chill = wind_chill;
    rec.apparent_temperature = apparent_temperature;
    rec.absolute_pressure = absolute_pressure;
    rec.average_wind_speed = average_wind_speed;
    rec.download_timestamp = download_timestamp;
    rec.wind_direction = wind_direction;
    rec.v1 = false;
    rec.station_type = station_hw_type;

    if (station_hw_type == ST_DAVIS) {
        EXEC SQL SELECT bar_trend,
                        rain_rate,
                        storm_rain,
                        coalesce(extract(epoch from current_storm_start_date)::integer,0),
                        transmitter_battery,
                        console_battery_voltage,
                        forecast_icon,
                        forecast_rule_id,
                        coalesce(uv_index, 0),
                        coalesce(solar_radiation, 0),
                        leaf_wetness_1,
                        leaf_wetness_2,
                        leaf_temperature_1,
                        leaf_temperature_2,
                        soil_moisture_1,
                        soil_moisture_2,
                        soil_moisture_3,
                        soil_moisture_4,
                        soil_temperature_1,
                        soil_temperature_2,
                        soil_temperature_3,
                        soil_temperature_4,
                        extra_temperature_1,
                        extra_temperature_2,
                        extra_temperature_3,
                        extra_humidity_1,
                        extra_humidity_2
                INTO :barometer_trend,
                     :rain_rate,
                     :storm_rain,
                     :current_storm_date,
                     :tx_battery_status,
                     :console_battery_voltage,
                     :forecast_icon,
                     :forecast_rule,
                     :uv_index,
                     :solar_radiation,
                     :leafWetness1 :leafWetness1_ind,
                     :leafWetness2 :leafWetness2_ind,
                     :leafTemperature1 :leafTemperature2_ind,
                     :leafTemperature2 :leafTemperature2_ind,
                     :soilMoisture1 :soilMoisture1_ind,
                     :soilMoisture2 :soilMoisture2_ind,
                     :soilMoisture3 :soilMoisture3_ind,
                     :soilMoisture4 :soilMoisture4_ind,
                     :soilTemperature1 :soilTemperature1_ind,
                     :soilTemperature2 :soilTemperature2_ind,
                     :soilTemperature3 :soilTemperature3_ind,
                     :soilTemperature4 :soilTemperature4_ind,
                     :extraTemperature1 :extraTemperature1_ind,
                     :extraTemperature2 :extraTemperature2_ind,
                     :extraTemperature3 :extraTemperature3_ind,
                     :extraHumidity1 :extraHumidity1_ind,
                     :extraHumidity2 :extraHumidity2_ind
                 FROM davis_live_data
                WHERE station_id = :station_id_param
                LIMIT 1;

        rec.davis_data.rain_rate = rain_rate;
        rec.davis_data.storm_rain = storm_rain;
        rec.davis_data.current_storm_start_date = current_storm_date;
        rec.davis_data.barometer_trend = barometer_trend;
        rec.davis_data.forecast_icon = forecast_icon;
        rec.davis_data.forecast_rule = forecast_rule;
        rec.davis_data.tx_battery_status = tx_battery_status;
        rec.davis_data.console_battery = console_battery_voltage;
        rec.davis_data.uv_index = uv_index;
        rec.davis_data.solar_radiation = solar_radiation;

        rec.davis_data.leafWetness1 = leafWetness1_ind == 0 ? leafWetness1 : NAN;
        rec.davis_data.leafWetness2 = leafWetness2_ind == 0 ? leafWetness2 : NAN;
        rec.davis_data.leafTemperature1 = leafTemperature1_ind == 0 ? leafTemperature1 : NAN;
        rec.davis_data.leafTemperature2 = leafTemperature2_ind == 0 ? leafTemperature2 : NAN;
        rec.davis_data.soilMoisture1 = soilMoisture1_ind == 0 ? soilMoisture1 : NAN;
        rec.davis_data.soilMoisture2 = soilMoisture2_ind == 0 ? soilMoisture2 : NAN;
        rec.davis_data.soilMoisture3 = soilMoisture3_ind == 0 ? soilMoisture3 : NAN;
        rec.davis_data.soilMoisture4 = soilMoisture4_ind == 0 ? soilMoisture4 : NAN;
        rec.davis_data.soilTemperature1 = soilTemperature1_ind == 0 ? soilTemperature1 : NAN;
        rec.davis_data.soilTemperature2 = soilTemperature2_ind == 0 ? soilTemperature2 : NAN;
        rec.davis_data.soilTemperature3 = soilTemperature3_ind == 0 ? soilTemperature3 : NAN;
        rec.davis_data.soilTemperature4 = soilTemperature4_ind == 0 ? soilTemperature4 : NAN;
        rec.davis_data.extraTemperature1 = extraTemperature1_ind == 0 ? extraTemperature1 : NAN;
        rec.davis_data.extraTemperature2 = extraTemperature2_ind == 0 ? extraTemperature2 : NAN;
        rec.davis_data.extraTemperature3 = extraTemperature3_ind == 0 ? extraTemperature3 : NAN;
        rec.davis_data.extraHumidity1 = extraHumidity1_ind == 0 ? extraHumidity1 : NAN;
        rec.davis_data.extraHumidity2 = extraHumidity2_ind == 0 ? extraHumidity2 : NAN;
    }

    return rec;
}

live_data_record wdb_get_live_data() {

    if (!connected) {
        live_data_record rec;

        rec.indoor_temperature = 0;
        rec.indoor_relative_humidity = 0;
        rec.temperature = 0;
        rec.relative_humidity = 0;
        rec.dew_point = 0;
        rec.wind_chill = 0;
        rec.apparent_temperature = 0;
        rec.absolute_pressure = 0;
        rec.average_wind_speed = 0;
        rec.wind_direction_str[0] = ' ';
        rec.wind_direction_str[1] = ' ';
        rec.wind_direction_str[2] = ' ';
        rec.wind_direction_str[3] = '\0';
        rec.wind_direction = 0;
        rec.download_timestamp = 0;
        rec.v1 = true;
        qDebug() << "Not connected - using empty data";
        return rec;
    }

    if (db_version == 1)
        return get_live_data_v1();
    else
        return get_live_data_v2();
}

int wdb_get_hardware_type() {
    return station_hw_type;
}
