/*****************************************************************************
 *            Created: 23/06/2012
 *          Copyright: (C) Copyright David Goodwin, 2012
 *            License: GNU General Public License
 *****************************************************************************
 *
 *   This is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This software is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this software; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 ****************************************************************************/

/*
 * QtSQL module doesn't seem to like Postgres (at least not recent versions).
 * So this is all done with ECPG instead. Yay.
 *
 * Remember: Keep it ANSI_C. Mostly. ECPG doesn't understand C++ but a little
 * bit of it (like the DBSignalAdapter stuff) shouldn't bother it too much.
 */

#include "database.h"
#include <string.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <QtDebug>

#define LIVE_DATA_UPDATE_CHANNEL "live_data_updated"

/* Globals */
static DBSignalAdapter* signalAdapter = NULL;
static int station_id = 0;
static char* station_code = 0;
static int station_code_len = 0;
static int db_version = 1;
static bool connected = false;

/* Forward Declarations */
int wdb_get_station_id(const char*);

/* Setup error handling */
EXEC SQL WHENEVER SQLERROR CALL wdb_print_sqlca();

/* In the event of a SQL error, print the details to stderr, roll back the
 * transaction, disconnect from the server and exit */
void wdb_print_sqlca()
{
    fprintf(stderr, "A database error has occurred.\n");
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");

    if (signalAdapter != NULL)
        signalAdapter->raiseDatabaseError(sqlca.sqlcode,
                                          sqlca.sqlerrm.sqlerrml,
                                          sqlca.sqlerrm.sqlerrmc,
                                          sqlca.sqlerrd,
                                          sqlca.sqlwarn,
                                          sqlca.sqlstate);
    else
        exit(EXIT_FAILURE);
}

void wdb_set_signal_adapter(DBSignalAdapter *adapter) {
    signalAdapter = adapter;
}

/* Checks that the main connection is still OK and if it isn't attempts to
 * reset it */
void check_data_connection() {
    PGconn* conn = ECPGget_PGconn("data_connection");
    if (conn == NULL) {
        qDebug() << "ERROR: NULL connection (primary)";
    }

    /* PQstatus doesn't seem to notice a lost database connection until we do
     * something else that interacts with the connection (like run a query).
     *
     * This may be a result of interference from ECPG as a similar check
     * on the notification connection (which doesn't use ECPG for anything
     * beyond setting up the connection) doesn't have this problem.
     *
     * Similar interference may be the reason why notifications have to be
     * processed on a separate connection too (if we listen on data_connection
     * we never receive them).
     */
    PQconsumeInput(conn);

    if (PQstatus(conn) == CONNECTION_BAD) {
        qDebug() << "Primary database connection seems to have gone bad. Attempting reset.";
        PQreset(conn);
        if (PQstatus(conn) == CONNECTION_BAD) {
            qDebug() << "ERROR: Failed to reestablish primary database connection.";
        } else {
            qDebug() << "Primary reconnect succeeded.";
        }
    }
}

/* Tries to figure out which version the database is. */
int get_db_version() {
    EXEC SQL BEGIN DECLARE SECTION;
    bool db_info_table_exists;
    int version;
    EXEC SQL END DECLARE SECTION;

    check_data_connection();

    EXEC SQL SELECT COUNT(*) = 1 INTO :db_info_table_exists
             FROM information_schema.tables WHERE table_name = 'db_info';

    /* v0.1 doesn't have the db_info table. Everything else should. */
    if (!db_info_table_exists)
        version = 1;
    else {
        /* For v0.2+ we can just ask the database what version it is */
        EXEC SQL SELECT CAST(v AS integer) INTO :version
                 FROM db_info WHERE k = 'DB_VERSION';
    }

    return version;
}

void subscribe_to_notifications(PGconn* conn) {
    PGresult *res = PQexec(conn, "LISTEN " LIVE_DATA_UPDATE_CHANNEL);
    if (PQresultStatus(res) != PGRES_COMMAND_OK) {
        qDebug() << "LISTEN failed. Live data notifications will not be processed.\n";
    }
    PQclear(res);
}

bool wdb_connect(const char *target, const char *username, const char* password,
                 const char *station) {
    EXEC SQL BEGIN DECLARE SECTION;
    const char * target_l = target;
    const char * username_l = username;
    const char * password_l = password;
    EXEC SQL END DECLARE SECTION;


    qDebug() << "Connecting to database...";

    // This is the primary connection and is used for all queries.
    EXEC SQL CONNECT TO :target_l AS data_connection USER :username_l USING :password_l;

    if (sqlca.sqlstate[0] != '0' || sqlca.sqlstate[1] != '0')
        return false;

    db_version = get_db_version();
    qDebug() << "Database version: " << db_version;

    qDebug() << "Setting up notification connection...";
    // This connection is used to listen for notifications. This is done on a
    // seperate connection because performing selects with ECPG seems to
    // interfere with receiving notifications.
    EXEC SQL CONNECT TO :target_l AS notification_connection USER :username_l USING :password_l;

    /* Subscribe to live data notifications */
    PGconn* conn = ECPGget_PGconn("notification_connection");
    if (conn == NULL) return false;
    subscribe_to_notifications(conn);

    // Switch back to the primary connection and finish off.
    EXEC SQL SET CONNECTION data_connection;
    EXEC SQL SET AUTOCOMMIT TO OFF;

    if (db_version > 1)
        station_id = wdb_get_station_id(station);

    station_code_len = strlen(station) + 1; /* +1 for null termination */
    station_code = (char*)malloc(station_code_len);
    memcpy(station_code, station, station_code_len);

    connected = true;

    return connected;
}

/* Gets the ID for the specified station code */
int wdb_get_station_id(const char* station) {
    EXEC SQL BEGIN DECLARE SECTION;
    const char * station_code = station;
    int station_id_param = 0;
    EXEC SQL END DECLARE SECTION;

    if (!connected) return 0;

    check_data_connection();

    if (db_version > 2) {
        EXEC SQL SELECT station_id
                 INTO :station_id_param
                 FROM station
                 WHERE code = :station_code;
    } else {
        station_id_param = 0;
    }

    return station_id_param;
}

void wdb_disconnect() {
    EXEC SQL DISCONNECT data_connection;
    EXEC SQL DISCONNECT notification_connection;
    free(station_code);
}

bool wdb_live_data_available() {
    qDebug() << "Checking for live data";
    if (!connected) return false;

    PGconn* conn = ECPGget_PGconn("notification_connection");
    if (conn == NULL) {
        qDebug() << "ERROR: NULL connection (secondary)";
        return false;
    }

    if (PQstatus(conn) == CONNECTION_BAD) {
        qDebug() << "Secondary database connection seems to have gone bad. Attempting reset.";
        PQreset(conn);
        if (PQstatus(conn) == CONNECTION_BAD) {
            qDebug() << "ERROR: Failed to reestablish secondary database connection.";
        } else {
            qDebug() << "Secondary reconnect succeeded.";
            subscribe_to_notifications(conn);
        }
    }

    bool live_data_available = false;

    PGnotify* notification;
    PQconsumeInput(conn);
    while ((notification = PQnotifies(conn)) != NULL) {
        qDebug() << "Received notification on channel" << notification->relname;
        qDebug() << "Payload:" << notification->extra;

        if (strcmp(notification->relname, LIVE_DATA_UPDATE_CHANNEL) == 0) {
            /* For v2+ schema we need to check the payload to ensure this is
             * for the station we're interested in */
            if ((db_version > 1) &&
                strncmp(station_code, notification->extra, station_code_len)) {
                // Live data is available for the station we are subscribed to.
                live_data_available = true;
            } else {
                /* the v1 schema doesn't use the payload to indicate station */
                live_data_available = true;
            }
        } else {
            qDebug() << "Ignore: Unknown channel";
        }
        PQfreemem(notification);
    }

    return live_data_available;
}

/* For zxweather v0.1 databases */
live_data_record get_live_data_v1() {
    EXEC SQL BEGIN DECLARE SECTION;
    int indoor_relative_humidity = 0;
    float indoor_temperature = 0.0;
    int relative_humidity = 0;
    float temperature = 0.0;
    float dew_point = 0.0;
    float wind_chill = 0.0;
    float apparent_temperature = 0.0;
    float absolute_pressure = 0.0;
    float average_wind_speed = 0.0;
    float gust_wind_speed = 0.0;
    char wind_direction[4];
    long download_timestamp = 0;
    EXEC SQL END DECLARE SECTION;

    memset(wind_direction, '\0', sizeof(char) * 4);

    check_data_connection();

    EXEC SQL SELECT ld.indoor_temperature,
                    ld.indoor_relative_humidity,
                    ld.temperature,
                    ld.relative_humidity,
                    ld.dew_point,
                    ld.wind_chill,
                    ld.apparent_temperature,
                    ld.absolute_pressure,
                    ld.average_wind_speed,
                    ld.gust_wind_speed,
                    ld.wind_direction,
                    extract(epoch from ld.download_timestamp)::integer
             INTO :indoor_temperature,
                  :indoor_relative_humidity,
                  :temperature,
                  :relative_humidity,
                  :dew_point,
                  :wind_chill,
                  :apparent_temperature,
                  :absolute_pressure,
                  :average_wind_speed,
                  :gust_wind_speed,
                  :wind_direction,
                  :download_timestamp
             FROM live_data ld
             LIMIT 1;

    live_data_record rec;
    rec.indoor_temperature = indoor_temperature;
    rec.indoor_relative_humidity = indoor_relative_humidity;
    rec.temperature = temperature;
    rec.relative_humidity = relative_humidity;
    rec.dew_point = dew_point;
    rec.wind_chill = wind_chill;
    rec.apparent_temperature = apparent_temperature;
    rec.absolute_pressure = absolute_pressure;
    rec.average_wind_speed = average_wind_speed;
    rec.gust_wind_speed = gust_wind_speed;
    rec.download_timestamp = download_timestamp;
    rec.v1 = true;
    strcpy(rec.wind_direction_str, wind_direction);

    return rec;
}

/* For v0.2+ */
live_data_record get_live_data_v2() {
    EXEC SQL BEGIN DECLARE SECTION;
    int indoor_relative_humidity = 0;
    float indoor_temperature = 0.0;
    int relative_humidity = 0;
    float temperature = 0.0;
    float dew_point = 0.0;
    float wind_chill = 0.0;
    float apparent_temperature = 0.0;
    float absolute_pressure = 0.0;
    float average_wind_speed = 0.0;
    float gust_wind_speed = 0.0;
    int wind_direction;
    long download_timestamp = 0;
    int station_id_param = station_id;
    EXEC SQL END DECLARE SECTION;

    check_data_connection();

    EXEC SQL SELECT ld.indoor_temperature,
                    ld.indoor_relative_humidity,
                    ld.temperature,
                    ld.relative_humidity,
                    ld.dew_point,
                    ld.wind_chill,
                    ld.apparent_temperature,
                    ld.absolute_pressure,
                    ld.average_wind_speed,
                    ld.gust_wind_speed,
                    ld.wind_direction,
                    extract(epoch from ld.download_timestamp)::integer
             INTO :indoor_temperature,
                  :indoor_relative_humidity,
                  :temperature,
                  :relative_humidity,
                  :dew_point,
                  :wind_chill,
                  :apparent_temperature,
                  :absolute_pressure,
                  :average_wind_speed,
                  :gust_wind_speed,
                  :wind_direction,
                  :download_timestamp
             FROM live_data ld
             WHERE ld.station_id = :station_id_param
             LIMIT 1;

    live_data_record rec;
    rec.indoor_temperature = indoor_temperature;
    rec.indoor_relative_humidity = indoor_relative_humidity;
    rec.temperature = temperature;
    rec.relative_humidity = relative_humidity;
    rec.dew_point = dew_point;
    rec.wind_chill = wind_chill;
    rec.apparent_temperature = apparent_temperature;
    rec.absolute_pressure = absolute_pressure;
    rec.average_wind_speed = average_wind_speed;
    rec.gust_wind_speed = gust_wind_speed;
    rec.download_timestamp = download_timestamp;
    rec.wind_direction = wind_direction;
    rec.v1 = false;

    return rec;
}

live_data_record wdb_get_live_data() {

    if (!connected) {
        live_data_record rec;

        rec.indoor_temperature = 0;
        rec.indoor_relative_humidity = 0;
        rec.temperature = 0;
        rec.relative_humidity = 0;
        rec.dew_point = 0;
        rec.wind_chill = 0;
        rec.apparent_temperature = 0;
        rec.absolute_pressure = 0;
        rec.average_wind_speed = 0;
        rec.gust_wind_speed = 0;
        rec.wind_direction_str[0] = ' ';
        rec.wind_direction_str[1] = ' ';
        rec.wind_direction_str[2] = ' ';
        rec.wind_direction_str[3] = '\0';
        rec.wind_direction = 0;
        rec.download_timestamp = 0;
        rec.v1 = true;

        return rec;
    }

    if (db_version == 1)
        return get_live_data_v1();
    else
        return get_live_data_v2();
}
