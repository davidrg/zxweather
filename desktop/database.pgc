/*****************************************************************************
 *            Created: 23/06/2012
 *          Copyright: (C) Copyright David Goodwin, 2012
 *            License: GNU General Public License
 *****************************************************************************
 *
 *   This is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This software is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this software; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 ****************************************************************************/

/*
 * QtSQL module doesn't seem to like Postgres (at least not recent versions).
 * So this is all done with ECPG instead. Yay.
 *
 * Remember: Keep it ANSI_C. Mostly. ECPG doesn't understand C++ but a little
 * bit of it (like the DBSignalAdapter stuff) shouldn't bother it too much.
 */

#include "database.h"
#include <string.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <QtDebug>

#define LIVE_DATA_UPDATE_CHANNEL "live_data_updated"

/* Globals */
static DBSignalAdapter* signalAdapter = NULL;
static int station_id = 0;

/* Forward Declarations */
int wdb_get_station_id(const char*);

/* Setup error handling */
EXEC SQL WHENEVER SQLERROR CALL wdb_print_sqlca();

/* In the event of a SQL error, print the details to stderr, roll back the
 * transaction, disconnect from the server and exit */
void wdb_print_sqlca()
{
    fprintf(stderr, "A database error has occurred.\n");
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");

    if (signalAdapter != NULL)
        signalAdapter->raiseDatabaseError(sqlca.sqlcode,
                                          sqlca.sqlerrm.sqlerrml,
                                          sqlca.sqlerrm.sqlerrmc,
                                          sqlca.sqlerrd,
                                          sqlca.sqlwarn,
                                          sqlca.sqlstate);
    else
        exit(EXIT_FAILURE);
}

void wdb_set_signal_adapter(DBSignalAdapter *adapter) {
    signalAdapter = adapter;
}

bool wdb_connect(const char *target, const char *username, const char* password,
                 const char *station) {
    EXEC SQL BEGIN DECLARE SECTION;
    const char * target_l = target;
    const char * username_l = username;
    const char * password_l = password;
    EXEC SQL END DECLARE SECTION;

    // This is the primary connection and is used for all queries.
    EXEC SQL CONNECT TO :target_l AS data_connection USER :username_l USING :password_l;

    if (sqlca.sqlstate[0] != '0' || sqlca.sqlstate[1] != '0')
        return false;

    // This connection is used to listen for notifications. This is done on a
    // seperate connection because performing selects with ECPG seems to
    // interfere with receiving notifications.
    EXEC SQL CONNECT TO :target_l AS notification_connection USER :username_l USING :password_l;

    /* Subscribe to live data notifications */
    PGconn* conn = ECPGget_PGconn("notification_connection");
    if (conn == NULL) return false;
    PGresult *res = PQexec(conn, "LISTEN " LIVE_DATA_UPDATE_CHANNEL);
    if (PQresultStatus(res) != PGRES_COMMAND_OK) {
        qDebug() << "LISTEN failed. Live data notifications will not be processed.\n";
    }
    PQclear(res);

    // Switch back to the primary connection and finish off.
    EXEC SQL SET CONNECTION data_connection;
    EXEC SQL SET AUTOCOMMIT TO OFF;

    station_id = wdb_get_station_id(station);

    return true;
}

/* Gets the ID for the specified station code */
int wdb_get_station_id(const char* station) {
    EXEC SQL BEGIN DECLARE SECTION;
    const char * station_code = station;
    int station_id_param = 0;
    EXEC SQL END DECLARE SECTION;


    EXEC SQL SELECT station_id
             INTO :station_id_param
             FROM station
             WHERE code = :station_code;

    return station_id_param;
}

void wdb_disconnect() {
    EXEC SQL DISCONNECT data_connection;
    EXEC SQL DISCONNECT notification_connection;
}

bool wdb_live_data_available() {
    PGconn* conn = ECPGget_PGconn("notification_connection");
    if (conn == NULL) {
        qDebug() << "ERROR: NULL connection";
        return false;
    }
    bool live_data_available = false;

    PGnotify* notification;
    PQconsumeInput(conn);
    while ((notification = PQnotifies(conn)) != NULL) {
        qDebug() << "Received notification on channel" << notification->relname;
        qDebug() << "Payload:" << notification->extra;

        if (strcmp(notification->relname, LIVE_DATA_UPDATE_CHANNEL) == 0) {
            // Live data is available.
            live_data_available = true;
        } else {
            qDebug() << "Ignore: Unknown channel";
        }
        PQfreemem(notification);
    }

    return live_data_available;
}

live_data_record wdb_get_live_data() {
    EXEC SQL BEGIN DECLARE SECTION;
    int indoor_relative_humidity = 0;
    float indoor_temperature = 0.0;
    int relative_humidity = 0;
    float temperature = 0.0;
    float dew_point = 0.0;
    float wind_chill = 0.0;
    float apparent_temperature = 0.0;
    float absolute_pressure = 0.0;
    float average_wind_speed = 0.0;
    float gust_wind_speed = 0.0;
    char wind_direction[4];
    long download_timestamp = 0;
    int station_id_param = station_id;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT ld.indoor_temperature,
                    ld.indoor_relative_humidity,
                    ld.temperature,
                    ld.relative_humidity,
                    ld.dew_point,
                    ld.wind_chill,
                    ld.apparent_temperature,
                    ld.absolute_pressure,
                    ld.average_wind_speed,
                    ld.gust_wind_speed,
                    ld.wind_direction,
                    extract(epoch from ld.download_timestamp)::integer
             INTO :indoor_temperature,
                  :indoor_relative_humidity,
                  :temperature,
                  :relative_humidity,
                  :dew_point,
                  :wind_chill,
                  :apparent_temperature,
                  :absolute_pressure,
                  :average_wind_speed,
                  :gust_wind_speed,
                  :wind_direction,
                  :download_timestamp
             FROM live_data ld
             WHERE ld.station_id = :station_id_param
             LIMIT 1;

    live_data_record rec;
    rec.indoor_temperature = indoor_temperature;
    rec.indoor_relative_humidity = indoor_relative_humidity;
    rec.temperature = temperature;
    rec.relative_humidity = relative_humidity;
    rec.dew_point = dew_point;
    rec.wind_chill = wind_chill;
    rec.apparent_temperature = apparent_temperature;
    rec.absolute_pressure = absolute_pressure;
    rec.average_wind_speed = average_wind_speed;
    rec.gust_wind_speed = gust_wind_speed;
    rec.download_timestamp = download_timestamp;

    strcpy(rec.wind_direction, wind_direction);

    return rec;
}
