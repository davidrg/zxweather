# coding=utf-8
"""
Tests the functions that deal with the loop packet type.
"""
import unittest
from davis_logger.record_types.loop import serialise_loop, deserialise_loop

__author__ = 'david'


def toHexString(string):
    """
    Converts the supplied string to hex.
    :param string: Input string
    :return:
    """
    result = ""
    for char in string:

        hex_encoded = hex(ord(char))[2:]
        if len(hex_encoded) == 1:
            hex_encoded = '0' + hex_encoded

        result += r'\x{0}'.format(hex_encoded)
    return result


class loop_tests(unittest.TestCase):

    loop_packets = [
        # These packets are with the console only having been logging for a
        # few hours so many values are 'dashed' (such as storm start time)
        b'\x4c\x4f\x4f\xec\x00\x27\x00\x87\x75\x0a\x03\x32\xca\x02\x00\x01\xcd'
        b'\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x34'
        b'\xff\xff\xff\xff\xff\xff\xff\x00\x00\xff\xff\x7f\x00\x00\xff\xff\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff'
        b'\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x40\x03\x00\xc1\x83\x02\xe8\x07\x0a\x0d\x0f\x6b',
        b'\x4c\x4f\x4f\xec\x00\x27\x00\x87\x75\x0a\x03\x32\xca\x02\x00\x01\xcd'
        b'\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x34'
        b'\xff\xff\xff\xff\xff\xff\xff\x00\x00\xff\xff\x7f\x00\x00\xff\xff\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff'
        b'\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x40\x03\x00\xc1\x83\x02\xe8\x07\x0a\x0d\x0f\x6b',
        b'\x4c\x4f\x4f\xec\x00\x27\x00\x87\x75\x0a\x03\x32\xca\x02\x00\x01\xcd'
        b'\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x34'
        b'\xff\xff\xff\xff\xff\xff\xff\x00\x00\xff\xff\x7f\x00\x00\xff\xff\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff'
        b'\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x40\x03\x00\xc1\x83\x02\xe8\x07\x0a\x0d\x0f\x6b',
        b'\x4c\x4f\x4f\xec\x00\x27\x00\x87\x75\x0a\x03\x32\xca\x02\x00\x01\xcd'
        b'\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x34'
        b'\xff\xff\xff\xff\xff\xff\xff\x00\x00\xff\xff\x7f\x00\x00\xff\xff\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff'
        b'\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x40\x03\x00\xc1\x83\x02\xe8\x07\x0a\x0d\x0f\x6b',
        b'\x4c\x4f\x4f\xec\x00\x27\x00\x87\x75\x0a\x03\x32\xca\x02\x00\x01\xcd'
        b'\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x34'
        b'\xff\xff\xff\xff\xff\xff\xff\x00\x00\xff\xff\x7f\x00\x00\xff\xff\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff'
        b'\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x40\x03\x00\xc1\x83\x02\xe8\x07\x0a\x0d\x0f\x6b',
    ]

    def test_round_trip(self):
        for packet in self.loop_packets:
            decoded = deserialise_loop(packet[0:97])
            encoded = serialise_loop(decoded)
            decoded2 = deserialise_loop(encoded[0:97])

            self.assertDictEqual(decoded._asdict(), decoded2._asdict())
            self.assertEqual(packet, encoded)

    def test_revision_a_packet_has_no_bar_trend(self):
        packet = self.loop_packets[0]

        rev_a_packet = bytearray()
        rev_a_packet.extend(b'LOOP')
        rev_a_packet.extend(packet[4:])

        decoded = deserialise_loop(rev_a_packet[0:97])

        self.assertIsNone(decoded.barTrend)
